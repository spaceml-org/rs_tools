#!/usr/bin/env python
"""
analyse_test_image.py

This script runs analysis routines on a test image generated by via
the 'mk_test_cat.py' and 'mk_test_image.py' scripts. It attempts to
fit the features in the image using degraded knowledge from the
catalogue as a starting point. This is likely useful as we are
interested in measuring the characteristics of known features, rather
than running a blind detection experiment. Care must be taken to
identify low-confidence fits in (for example) low signal-to-noise
areas, so we can identify when our analysis fails.

Functions:
- do_gaussian2D_fit() -> Dict:
    Fit a single 2D Gaussian to a patch of image.
- plot_gaussian_fit() -> None
    Plot the data, model fit and residual.
- run_sequential_fits() -> None:
    Fit individual features in sequence.

"""

import os
import re
import sys
import argparse
import numpy as np
import math
import rasterio
from rasterio.transform import Affine
from tqdm import tqdm as tq
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse

from mpfit import mpfit
from utils_fidelity import (
    csv_read_to_list,
    twodgaussian,
    vect_to_mpfit_parms,
    get_parm_vector)


#-----------------------------------------------------------------------------#
def do_gaussian2D_fit(p, data_arr, quiet=True):
    """
    Fit a 2D Gaussian model to a section of an image.

    Intial guess at parameters:
        p = [amp, x0, y0, sig_x, sig_y, pa]

    """

    # Convert to a MPFIT parameter vector
    p_names = ["amp", "x0", "y0", "sig_x", "sig_y", "pa"]
    inparms = vect_to_mpfit_parms(p, p_names)

    # Fit the Gaussian using MPFIT
    def err_mpfit_fn(p, fjac=None):
        status = 0
        return status, np.ravel(twodgaussian(p)
                                (*np.indices(data_arr.shape))
                                - data_arr)
    mp = mpfit(err_mpfit_fn, parinfo=inparms, quiet=quiet)

    # Calculate goodness-of-fit parameters
    n_free_parms = sum(~np.array(get_parm_vector(inparms, "fixed")))
    dof = len(data_arr) - n_free_parms - 1
    fit_dict = {}
    fit_dict["chi_sq"] = mp.fnorm
    fit_dict["chi_sq_red"] = mp.fnorm / dof
    fit_dict["n_iter"] = mp.niter
    fit_dict["p_err"] = mp.perror
    fit_dict["inparms"] = inparms

    return mp, fit_dict


#-----------------------------------------------------------------------------#
def plot_gaussian_fit(fig, p, data_arr):
    """
    Plot the results of the Gaussian fits for debugging.
    """

    # Plot the data and fit ellipse
    ax1 = fig.add_subplot(1,3,1)
    cax1 = ax1.imshow(data_arr, origin='lower', cmap=mpl.cm.jet)
    cbar1=fig.colorbar(cax1, pad=0.0)
    sigma2fwhm = math.sqrt(8*math.log(2))
    ellipse = Ellipse(
        xy=(p[1], p[2]),
        width=p[3] * sigma2fwhm,
        height=p[4]* sigma2fwhm,
        angle=-1*p[5],
        edgecolor="magenta",
        fc="None",
        lw=2)
    ax1.add_patch(ellipse)
    ax1.set_title("Generated Data")
    ax1.set_xlim(0, data_arr.shape[-1]-1)
    ax1.set_ylim(0, data_arr.shape[-2]-1)
    ax1.set_aspect('equal')

    # Plot the model fit
    fit_arr = twodgaussian(p, data_arr.shape)
    ax2 = fig.add_subplot(1,3,2)
    cax2 = ax2.imshow(fit_arr, origin='lower', cmap=mpl.cm.jet)
    cbar2=fig.colorbar(cax2, pad=0.0)
    ax2.set_title("Model Fit")

    # Plot the residual
    ax3 = fig.add_subplot(1,3,3)
    res_arr = data_arr - fit_arr
    cax3 = ax3.imshow(res_arr, origin='lower', cmap=mpl.cm.jet)
    cbar2=fig.colorbar(cax3, pad=0.0)
    ax3.set_title("Residual")

    fig.canvas.draw()
    fig.show()
    input("Press <RETURN> to continue ...")


#-----------------------------------------------------------------------------#
def run_sequential_fits(image_file, cat_file, jitter=0.01, verbose=False,
                        debug=False):
    """
    Sequentially fit the features in the input image.
    """

    # Read the image file
    if not os.path.exists(image_file):
        sys.exit(f"[ERR] File does not exist: '{image_file}'.")
    with rasterio.open(image_file) as src:
        data_arr = src.read(1)
        y_size, x_size = data_arr.shape
    print(f"[INFO] Read image of shape {data_arr.shape}.")

    # Read catalogue file
    if not os.path.exists(cat_file):
        sys.exit(f"[ERR] File does not exist: '{cat_file}'.")
    cat_lst = csv_read_to_list(cat_file, do_float=True)
    num_entries = len(cat_lst)
    print(f"[INFO] found {num_entries} entries in the catalogue.")


    fig = plt.figure(facecolor="w", figsize=(9.5, 8))
    ax = fig.add_axes([0.1, 0.08, 0.9, 0.87])

    # Loop through the catalogue and fit individually
    for idx, e in enumerate(tq(cat_lst, desc="FITTING")):
        src_type = int(e[0])

        # Fit a Gaussian
        if src_type == 1:

            # Parse the properties of the Gaussian from catalogue
            x0 = e[1] * x_size
            y0 = e[2] * y_size
            sig_x = e[3]
            sig_y = e[4]
            pa = e[5]
            amp = e[6]

            # Estimate an island containing the source
            # For Gaussians, assume a 5-sigma distance
            r = max(sig_x, sig_y) * 5
            x1 = max(int(round(x0 - r)), 0)
            x2 = min(int(round(x0 + r)), x_size)
            y1 = max(int(round(y0 - r)), 0)
            y2 = min(int(round(y0 + r)), y_size)

            # Extract a sub-image centred on the feature
            sub_arr = data_arr[y1:y2, x1:x2]
            yi, xi = np.indices(sub_arr.shape)
            x0 -= x1
            y0 -= y1

            # Add jitter to set the starting parameters for fit
            x0 *= (1 + jitter * np.random.uniform(-1, 1))
            y0 *= (1 + jitter * np.random.uniform(-1, 1))
            sig_x *= (1 + jitter * np.random.uniform(-1, 1))
            sig_y *= (1 + jitter * np.random.uniform(-1, 1))
            pa *= (1 + jitter * np.random.uniform(-1, 1)) % 180.0
            amp *= (1 + jitter * np.random.uniform(-1, 1))

            # Perform the fit and update p with best values
            p = [amp, x0, y0, sig_x, sig_y, pa]
            mp, fit_dict = do_gaussian2D_fit(p, sub_arr, quiet=not(verbose))
            p = mp.params
            inparms = fit_dict["inparms"]

            # Feedback to user
            tq.write("[INFO] Final fit values:\n")
            for i_ in range(len(p)):
                tq.write("\t%s = %f +/- %f" % (inparms[i_]['parname'],
                                               mp.params[i_],
                                               mp.perror[i_]))
            tq.write("\n\tChiSq:         %.1f" % fit_dict["chi_sq"])
            tq.write("\tChiSq Reduced: %.1f" % fit_dict["chi_sq_red"])
            tq.write("\tN Iter:        %d\n" % fit_dict["n_iter"])

            # DEBUG: Plot the individual fits
            if debug:
                fig = plt.figure(figsize=(18,4.3))
                plot_gaussian_fit(fig, p, sub_arr)

            # TODO: Save final values to dataframe for later comparison


#-----------------------------------------------------------------------------#
if __name__ == '__main__':

    desc_str = """
    Create a new catalogue of features to populate a testing
    image. This initial version generates Gaussian features with
    uniformly distributed properties between two limits."""

    epilog_str = """
    Copyleft Trillium Technologies 2024.
    Queries to team@trillium.tech.
    """

    # Parse the command line options
    ap = argparse.ArgumentParser(description=desc_str, epilog=epilog_str,
                                 formatter_class=argparse.RawTextHelpFormatter)

    ap.add_argument(
        "--image",
        required=True,
        help="Input image file."
    )
    ap.add_argument(
        "--cat",
        required=True,
        help="Input catalogue file."
    )
    ap.add_argument(
        "--verbose",
        action='store_true',
        help="Print verbose messages."
    )
    ap.add_argument(
        "--debug",
        action='store_true',
        help="Show debugging messages and plots."
    )
    args = ap.parse_args()

    # Call the function to run the fits
    run_sequential_fits(
        image_file=args.image,
        cat_file=args.cat,
        verbose=args.verbose,
        debug=args.debug)
