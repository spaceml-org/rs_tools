#!/usr/bin/env python
"""
analyse_test_image.py

This script runs analysis routines on a test image generated by via
the 'mk_test_cat.py' and 'mk_test_image.py' scripts. It attempts to
fit the features in the image using degraded knowledge from the
catalogue as a starting point. This is useful as we are interested in
measuring the characteristics of known features, rather than running a
blind detection experiment. Care must be taken to identify
low-confidence fits in (for example) low signal-to-noise areas, so we
can identify when our analysis fails.

Functions:
- do_gaussian2D_fit() -> Dict:
    Fit a single 2D Gaussian to a patch of image.
- plot_gaussian_fit() -> None
    Plot the data, model fit and residual.
- run_sequential_fits() -> None:
    Fit individual features in sequence.

"""

import os
import re
import sys
import copy
import argparse
import numpy as np
import math
import rasterio
from rasterio.transform import Affine
from tqdm import tqdm as tq
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
import pandas as pd

from mpfit import mpfit
from utils_fidelity import (
    csv_read_to_list,
    twodgaussian,
    vect_to_mpfit_parms,
    get_parm_vector
)


#-----------------------------------------------------------------------------#
def do_gaussian2D_fit(p, data_arr, quiet=True):
    """
    Fit a 2D Gaussian model to a section of an image.

    Intial guess at parameters:
        p = [amp, x0, y0, sig_x, sig_y, pa]

    """

    # Convert to a MPFIT parameter vector
    p_names = ["amp", "x0", "y0", "sig_x", "sig_y", "pa"]
    inparms = vect_to_mpfit_parms(p, p_names)

    # Fit the Gaussian using MPFIT
    def err_fn(p, fjac=None):
        status = 0
        return status, np.ravel(twodgaussian(p)
                                (*np.indices(data_arr.shape))
                                - data_arr)
    mp = mpfit(err_fn, parinfo=inparms, quiet=quiet)

    # Calculate goodness-of-fit parameters
    fit_dict = {}
    fit_dict["n_free_parms"] = sum(~np.array(get_parm_vector(inparms, "fixed")))
    fit_dict["dof"] = data_arr.size - fit_dict["n_free_parms"] - 1
    fit_dict["chi_sq"] = mp.fnorm
    fit_dict["chi_sq_red"] = mp.fnorm / fit_dict["dof"]
    fit_dict["n_iter"] = mp.niter
    fit_dict["p_err"] = mp.perror
    fit_dict["inparms"] = inparms

    return mp, fit_dict


#-----------------------------------------------------------------------------#
def plot_gaussian_fit(fig, p, data_arr):
    """
    Plot the results of the Gaussian fits for debugging.
    """

    # Plot the data and fit ellipse
    ax1 = fig.add_subplot(1,3,1)
    cax1 = ax1.imshow(data_arr, origin='lower', cmap=mpl.cm.jet)
    cbar1 = fig.colorbar(cax1, pad=0.0)
    sigma2fwhm = math.sqrt(8*math.log(2))
    ellipse = Ellipse(
        xy=(p[1], p[2]),
        width=p[3] * sigma2fwhm,
        height=p[4]* sigma2fwhm,
        angle=-1*p[5],
        edgecolor="magenta",
        fc="None",
        lw=2)
    ax1.add_patch(ellipse)
    ax1.set_title("Generated Data")
    ax1.set_xlim(0, data_arr.shape[-1]-1)
    ax1.set_ylim(0, data_arr.shape[-2]-1)
    ax1.set_aspect('equal')

    # Plot the model fit
    fit_arr = twodgaussian(p, data_arr.shape)
    ax2 = fig.add_subplot(1,3,2)
    cax2 = ax2.imshow(fit_arr, origin='lower', cmap=mpl.cm.jet)
    cbar2=fig.colorbar(cax2, pad=0.0)
    ax2.set_title("Model Fit")

    # Plot the residual
    ax3 = fig.add_subplot(1,3,3)
    res_arr = data_arr - fit_arr
    cax3 = ax3.imshow(res_arr, origin='lower', cmap=mpl.cm.jet)
    cbar2=fig.colorbar(cax3, pad=0.0)
    ax3.set_title("Residual")


#-----------------------------------------------------------------------------#
def run_sequential_fits(image_file, cat_file, jitter=0.01, sigma_extract=3.0,
                        verbose=False, debug=False):
    """
    Sequentially fit the features in the input image.
    """

    # Read the image file
    if not os.path.exists(image_file):
        sys.exit(f"[ERR] File does not exist: '{image_file}'.")
    with rasterio.open(image_file) as src:
        data_arr = src.read(1)
        y_size, x_size = data_arr.shape
    print(f"[INFO] Read image of shape {data_arr.shape}.")

    # Read catalogue file
    if not os.path.exists(cat_file):
        sys.exit(f"[ERR] File does not exist: '{cat_file}'.")
    cat_lst = csv_read_to_list(cat_file, do_float=True)
    num_entries = len(cat_lst)
    print(f"[INFO] found {num_entries} entries in the catalogue.")

    # Input and output parameters are stored in lists -> DataFrames
    gauss_cat_lst = []

    # Setup the figure for plotting individual Gaussian fits
    if debug:
        fig1 = plt.figure(facecolor="w", figsize=(18, 4.3))
        ax1 = fig1.add_axes([0.1, 0.08, 0.9, 0.87])

    # Loop through the catalogue and fit individually
    for idx, e in enumerate(tq(cat_lst, desc="FITTING")):
        src_type = int(e[0])

        # Fit a Gaussian
        if src_type == 1:

            # Parse the properties of the Gaussian from catalogue
            gauss_cat_row = e[1:]       # For saving to DataFrame
            gauss_cat_row[1] *= x_size  # Convert relative -> absolute
            gauss_cat_row[2] *= y_size  #     positions on large image
            amp = e[1]
            x0 = e[2] * x_size
            y0 = e[3] * y_size
            sig_x = e[4]
            sig_y = e[5]
            pa = e[6]

            # Estimate an island containing the source
            r = max(sig_x, sig_y) * sigma_extract
            x1 = max(int(round(x0 - r)), 0)
            x2 = min(int(round(x0 + r)), x_size)
            y1 = max(int(round(y0 - r)), 0)
            y2 = min(int(round(y0 + r)), y_size)

            # Extract a sub-image centred on the feature
            # and shift the centre position to the new frame
            sub_arr = data_arr[y1:y2, x1:x2]
            yi, xi = np.indices(sub_arr.shape)
            x0 -= x1
            y0 -= y1

            # Add jitter to set the starting parameters for fitter
            x0 *= (1 + jitter * np.random.uniform(-1, 1))
            y0 *= (1 + jitter * np.random.uniform(-1, 1))
            sig_x *= (1 + jitter * np.random.uniform(-1, 1))
            sig_y *= (1 + jitter * np.random.uniform(-1, 1))
            pa *= (1 + jitter * np.random.uniform(-1, 1)) % 180.0
            amp *= (1 + jitter * np.random.uniform(-1, 1))

            # Perform the fit and update p with best values
            p = [amp, x0, y0, sig_x, sig_y, pa]
            mp, fit_dict = do_gaussian2D_fit(p, sub_arr, quiet=not(verbose))
            if mp.status <= 0:
                print(f"[WARN] Fit failed on feature {idx+1}! Skipping.\n")
                continue
            p = mp.params
            p[5] %= 180.0
            inparms = fit_dict["inparms"]

            # Feedback to user
            tq.write(f"[INFO] Final fit values for feature {idx+1}:\n")
            for i_ in range(len(p)):
                tq.write("\t%s = %f +/- %f" % (inparms[i_]['parname'],
                                               mp.params[i_],
                                               mp.perror[i_]))
            tq.write("\n\tChiSq:       %.1f" % fit_dict["chi_sq"])
            tq.write("\tDoF:           %d" % fit_dict["dof"])
            tq.write("\tChiSq Reduced: %.1f" % fit_dict["chi_sq_red"])
            tq.write("\tN Iter:        %d\n" % fit_dict["n_iter"])

            # Add the catalogue entry and fit results to a list-of-lists
            gauss_fit_row = copy.copy(p)
            gauss_fit_row[1] +=x1   # Shift to the image reference frame
            gauss_fit_row[2] +=y1   #
            gauss_cat_lst.append(gauss_cat_row + gauss_fit_row.tolist())

            # DEBUG: Plot the individual fits
            if debug:
                fig1.clf()
                plot_gaussian_fit(fig1, p, sub_arr)
                fig1.canvas.draw()
                fig1.show()
                input("Press <RETURN> to continue ...")

    # Save final values to dataframes for later comparison
    root, ext = os.path.splitext(cat_file)
    out_df_filename = root + "_fit.pkl"
    gauss_df = pd.DataFrame(gauss_cat_lst,
                            columns=["amp_cat",
                                     "x0_cat",
                                     "y0_cat",
                                     "sig_x_cat",
                                     "sig_y_cat",
                                     "pa_cat",
                                     "amp_fit",
                                     "x0_fit",
                                     "y0_fit",
                                     "sig_x_fit",
                                     "sig_y_fit",
                                     "pa_fit"])
    print(f"[INFO] Saving results to '{out_df_filename}'.")
    gauss_df.to_pickle(out_df_filename)

    # Plot the catalogue and fits as ellipses over the image
    fig2 = plt.figure(facecolor="w", figsize=(8, 7))
    ax2 = fig2.add_axes([0.1, 0.08, 0.9, 0.87])
    cax2 = ax2.imshow(data_arr, origin='lower', cmap=mpl.cm.gray)
    cbar2 = fig2.colorbar(cax2, pad=0.0)
    sigma2fwhm = math.sqrt(8*math.log(2))
    for idx, row in gauss_df.iterrows():
        ell_cat = Ellipse(
            xy=(row.x0_cat, row.y0_cat),
            width=row.sig_x_cat * sigma2fwhm,
            height=row.sig_y_cat * sigma2fwhm,
            angle=-1*row.pa_cat,
            edgecolor="lightgreen",
            fc="None",
            lw=3)
        ax2.add_patch(ell_cat)
        ell_fit = Ellipse(
            xy=(row.x0_fit, row.y0_fit),
            width=row.sig_x_fit * sigma2fwhm,
            height=row.sig_y_fit * sigma2fwhm,
            angle=-1*row.pa_fit,
            edgecolor="magenta",
            fc="None",
            lw=1)
        ax2.add_patch(ell_fit)
    ax2.set_aspect("equal")
    ax2.set_xlabel("X (pixels)")
    ax2.set_ylabel("Y (pixels)")
    cbar2.set_label("Amplitude")

    # Save the plot to disk as a png
    root, ext = os.path.splitext(image_file)
    fig_filename = root + "_fit.png"
    print(f"[INFO] Saving plot to '{fig_filename}'.")
    fig2.savefig(fig_filename, dpi=300)
    fig2.show()
    input("Press <RETURN> to continue ...")


#-----------------------------------------------------------------------------#
if __name__ == '__main__':

    desc_str = """
    Create a new catalogue of features to populate a testing
    image. This initial version generates Gaussian features with
    uniformly distributed properties between two limits."""

    epilog_str = """
    Copyleft Trillium Technologies 2024.
    Queries to team@trillium.tech.
    """

    # Parse the command line options
    ap = argparse.ArgumentParser(description=desc_str, epilog=epilog_str,
                                 formatter_class=argparse.RawTextHelpFormatter)

    ap.add_argument(
        "--image",
        required=True,
        help="Input image file."
    )
    ap.add_argument(
        "--cat",
        required=True,
        help="Input catalogue file."
    )
    ap.add_argument(
        "--jitter",
        default=0.01,
        type=float,
        help="Randomise fit start parameters by this factor [%(default)s]."
    )
    ap.add_argument(
        "--sigma-extract",
        default=3.0,
        type=float,
        help="Radius (sigma) of postage stamp for fitting [%(default)s]."
    )
    ap.add_argument(
        "--verbose",
        action='store_true',
        help="Print verbose messages."
    )
    ap.add_argument(
        "--debug",
        action='store_true',
        help="Show debugging messages and plots."
    )
    args = ap.parse_args()

    # Call the function to run the fits
    run_sequential_fits(
        image_file=args.image,
        cat_file=args.cat,
        jitter=args.jitter,
        sigma_extract=args.sigma_extract,
        verbose=args.verbose,
        debug=args.debug)
